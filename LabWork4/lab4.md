# Лабораторная работа 4
## Проектирование REST API

## Цель работы
Получить опыт проектирования программного интерфейса.

## Документация по API
### Принятые проектные решения

1. **Архитектурное разбиение на сервисы по ответственностям**
   - Бек разделён на доменные области: API-слой, оркестратор RAG, индексатор, интеграция с VCS, хранилища (vector + metadata), очередь/воркеры.
   - Причина: независимое масштабирование и упрощение сопровождения.

2. **RAG как основной механизм ответа**
   - Бек не “угадывает” по модели, а сначала извлекает релевантные фрагменты из индекса и только затем формирует ответ.
   - Причина: привязка ответа к коду/докам репозитория и управляемость качества.

3. **Конвейерная обработка запроса (pipeline)**
   - Внутри RAG-сервиса этапы разделены: нормализация запроса → retrieval → (опционально) rerank → сбор контекста → построение prompt → вызов LLM → постобработка.
   - Причина: тестируемость, возможность заменять этапы без переписывания всего сервиса.

4. **Два типа хранилищ: Vector DB и реляционная БД**
   - Vector DB хранит эмбеддинги чанков и обеспечивает kNN/semantic search.
   - Реляционная БД хранит метаданные (репозитории, документы, версии индекса, статусы задач, аудит, связи «файл → чанки»).
   - Причина: разные модели доступа/индексации и разные требования к транзакционности.

5. **Инкрементальная индексация вместо полной переиндексации**
   - При изменениях обрабатываются только затронутые файлы/чанки; поддерживается версия/ревизия индекса.
   - Причина: ускорение обновлений и снижение нагрузки.

6. **Асинхронность тяжёлых операций через очередь и воркеры**
   - Индексация, переиндексация, массовая загрузка репо выполняются воркерами, запуск — через постановку задач в очередь.
   - Причина: API остаётся отзывчивым, управление ретраями/распараллеливанием.

7. **Идемпотентность и повторяемость задач индексатора**
   - Задачи индексирования проектируются так, чтобы повторный запуск не ломал состояние: одинаковый вход → одинаковый результат (или безопасное обновление).
   - Причина: надёжность при сбоях воркеров/очереди.

8. **Единая модель идентификации сущностей**
   - Вводятся стабильные идентификаторы: `repo_id`, `document_id`, `chunk_id`, `index_version`, `job_id`.
   - Причина: корректные связи между метаданными и векторами.

9. **Контроль доступа на стороне бекенда**
   - Бек проверяет права пользователя на репозиторий/ветку/проект на основе данных интеграции с VCS/SSO; запрещает выдачу контекста из недоступных репозиториев.
   - Причина: безопасность и соответствие корпоративным требованиям.

---

## Эндпоинты

### 1) Регистрация репозитория
**POST** `/api/v1/repos`  
Создаёт запись репозитория в системе (URL/проект/ветка по умолчанию/настройки).

**Request body**
```jsonc
{
  "name": "backend_repo", // Название репозитория в системе (человекочитаемое)
  "vcs_url": "https://gitlab.example.com/app1_group/backend_repo", // URL репозитория в VCS (GitLab/GitHub и т.п.)
  "default_ref": "main" // Ветка/референс по умолчанию
}
```

**Responses**
- **201 Created**
```jsonc
{
  "repo_uuid": "79fd7e3a-93f4-44dd-b8ea-87090fea36a2", // UUID репозитория, сгенерированный системой
  "status": "created" // Итог операции создания
}
```
- **400 Bad Request**
- **409 Conflict**

---

### 2) Список репозиториев
**GET** `/api/v1/repos`  
Возвращает репозитории, доступные пользователю (с учётом прав).

**Responses**
- **200 OK**
```jsonc
[
  {
    "repo_uuid": "79fd7e3a-93f4-44dd-b8ea-87090fea36a2", // UUID репозитория
    "name": "backend_repo", // Название репозитория
    "default_ref": "main" // Ветка по умолчанию
  }
]
```

---

### 3) Запуск индексации (задача в очередь)
**POST** `/api/v1/repos/{repo_id}/index-jobs`  
Ставит задачу индексирования (`full` или `incremental`) для `ref/commit`.

**Request body**
```jsonc
{
  "ref": "main", // Ветка/тег/commit, относительно которого выполнять индексацию
  "mode": "incremental" // Режим индексации: full | incremental
}
```

**Responses**
- **202 Accepted**
```jsonc
{
  "job_uuid": "1b9096f5-dfa3-4c6a-a90e-bb2f3a4966b2", // UUID созданной задачи индексации
  "status": "queued" // Текущий статус задачи (в очереди)
}
```

---

### 4) Проверка статуса задачи индексации
**GET** `/api/v1/index-jobs/{job_id}`  
Статус: `queued/running/succeeded/failed` + прогресс/ошибка.

**Responses**
- **200 OK**
```jsonc
{
  "job_uuid": "1b9096f5-dfa3-4c6a-a90e-bb2f3a4966b2", // UUID задачи индексации
  "status": "running", // Текущий статус задачи: queued | running | succeeded | failed
  "progress": 0.35, // Прогресс выполнения от 0.0 до 1.0
  "started_at": "2026-01-26T10:12:00Z" // Время старта задачи (ISO 8601, UTC)
}
```

---

### 5) Поиск по базе знаний (retrieval)
**POST** `/api/v1/search`  
Семантический поиск по чанкам: возвращает топ‑N фрагментов (для дебага retrieval и для отчёта).

**Request body**
```jsonc
{
  "repo_uuid": "79fd7e3a-93f4-44dd-b8ea-87090fea36a2", // UUID репозитория, по которому выполняется поиск
  "ref": "main", // Ветка/референс, относительно которого берётся индекс
  "query": "Опиши микросервис аналитики", // Поисковый запрос (текст)
  "top_k": 5 // Количество возвращаемых результатов (top‑K)
}
```

**Responses**
- **200 OK**
```jsonc
{
  "items": [
    {
      "chunk_uuid": "808d1366-384f-479b-ae5e-8f435a03cc29", // UUID найденного чанка
      "path": "analytics/src/chunk_analyzer.py", // Путь к файлу-источнику чанка в репозитории
      "score": 0.82, // Релевантность/скор (чем больше — тем релевантнее)
      "snippet": "..." // Короткий фрагмент текста (выдержка из чанка)
    }
  ]
}
```

---

### 6) Вопрос-ответ (RAG chat)
**POST** `/api/v1/chat/completions`  
Возвращает финальный ответ LLM + ссылки на источники.

**Request body**
```jsonc
{
  "repo_uuid": "79fd7e3a-93f4-44dd-b8ea-87090fea36a2", // UUID репозитория, по которому формируется ответ
  "ref": "main", // Ветка/референс, относительно которого берётся индекс
  "question": "Скажи, почему пайплайн не срабатывает на 3 стадии?", // Вопрос пользователя
  "max_sources": 3 // Максимальное число источников (чанков) в ответе
}
```

**Responses**
- **200 OK**
```jsonc
{
  "answer": "...", // Сгенерированный ответ (итог RAG)
  "sources": [
    {
      "path": ".gitlab-ci.yml", // Файл-источник
      "chunk_uuid": "0f486e7f-fa8a-41aa-b66a-1e4899ad16d4" // UUID чанка, из которого взят контекст
    }
  ]
}
```

---

### 7) Обновление настроек репозитория
**PUT** `/api/v1/repos/{repo_id}`  
Обновляет параметры репозитория (например, имя и ветку по умолчанию).

**Request body**
```jsonc
{
  "name": "backend_repo_v2", // Новое название репозитория
  "default_ref": "develop" // Новая ветка по умолчанию
}
```

**Responses**
- **200 OK**
```jsonc
{
  "repo_uuid": "79fd7e3a-93f4-44dd-b8ea-87090fea36a2", // UUID репозитория
  "status": "updated", // Итог операции обновления
  "name": "backend_repo_v2", // Актуальное название
  "default_ref": "develop" // Актуальная ветка по умолчанию
}
```
- **400 Bad Request**
- **404 Not Found**
- **409 Conflict**

---

### 8) Удаление репозитория и связанных данных
**DELETE** `/api/v1/repos/{repo_id}`  
Удаляет запись репозитория из системы и связанные данные индекса.

**Responses**
- **204 No Content**
- **404 Not Found**
- **409 Conflict**
